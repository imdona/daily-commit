'''
첫번째 문제
우리가 작성할 함수 min_coin_count는 거슬러 줘야 하는 총액 value와 동전 리스트 coin_list를 파라미터로 받고,
거슬러 주기 위해 필요한 최소 동전 개수를 리턴합니다.
'''
def min_coin_count(value, coin_list):
    # 누적 동전 개수
    count = 0

    # coin_list의 값들을 큰 순서대로 본다
    for coin in sorted(coin_list, reverse=True):
        # 현재 동전으로 몇 개 거슬러 줄 수 있는지 확인한다
        count += (value // coin)

        # 잔액을 계산한다
        value %= coin

    return count

# 테스트
default_coin_list = [100, 500, 10, 50]
print(min_coin_count(1440, default_coin_list))
print(min_coin_count(1700, default_coin_list))
print(min_coin_count(23520, default_coin_list))
print(min_coin_count(32590, default_coin_list))


########################################################################
'''
두번째 문제
여럿이서 카드 게임을 하고 있는데, 각 플레이어는 3장의 카드를 들고 있습니다.

test_cards = [[1, 2, 3], [4, 6, 1], [8, 2, 4], [3, 2, 5], [5, 2, 3], [3, 2, 1]]

위의 경우 첫 번째 플레이어는 1, 2, 3을 들고 있고, 두 번째 플레이어는 4, 6, 1을 들고 있고, 세 번째 플레이어는 8, 2, 4를 들고 있는 거죠.
함수 max_product는 한 사람당 카드를 하나씩 뽑아서 모두 곱했을 때 가능한 최대 곱을 리턴합니다. max_product를 Greedy Algorithm 방식으로 구현해 보세요.

1. 최적 부분 구조
    max_product([[1, 2, 4], [8, 2, 4], [3, 4, 1], [9, 6, 3]]) 이런 경우가 있다고 가정합시다.
    이 문제를 풀기 위해서는 우선 max_product([[1, 2, 4], [8, 2, 4], [3, 4, 1]])를 풀어야 합니다.
    그리고 그 결과값을 9랑 곱한 값, 6이랑 곱한 값, 3이랑 곱한 값 중 가장 큰 값이 기존 문제의 정답이 되겠죠.
    부분 문제의 정답을 이용해서 기존 문제의 정답을 구할 수 있기 때문에, 이 문제에는 최적 부분 구조가 있습니다.

2. 탐욕적 선택 속성
    이 문제를 풀기 위한 탐욕적 선택으로 가장 뻔한 답은, 각 카드 뭉치(각 리스트)에서 가장 큰 값을 고르는 것입니다.
    이런 선택이 과연 최적의 솔루션을 보장해 줄까요?
    각 값은 카드에 적혀 있는 숫자이기 때문에 0보다 큰 양수입니다.
    따라서 무조건 큰 숫자를 고르는 게 최적의 선택이라고 확신할 수 있습니다. 이 문제에 탐욕적 선택 속성이 존재하는 거죠.
'''
def max_product(card_lists):
    # 누적된 곱을 저장하는 변수
    product = 1

    # 반복문을 돌면서 카드 뭉치를 하나씩 본다
    for card_list in card_lists:
        # product에 각 뭉치의 최댓값을 곱해 준다
        product *= max(card_list)

    return product


# 테스트
test_cards1 = [[1, 6, 5], [4, 2, 3]]
print(max_product(test_cards1))

test_cards2 = [[9, 7, 8], [9, 2, 3], [9, 8, 1], [2, 8, 3], [1, 3, 6], [7, 7, 4]]
print(max_product(test_cards2))

test_cards3 = [[1, 2, 3], [4, 6, 1], [8, 2, 4], [3, 2, 5], [5, 2, 3], [3, 2, 1]]
print(max_product(test_cards3))

test_cards4 = [[5, 5, 5], [4, 3, 5], [1, 1, 1], [9, 8, 3], [2, 8, 4], [5, 7, 4]]
print(max_product(test_cards4))


########################################################################
'''
세번째 문제
익중이네 밴드부는 매주 수요일 오후 6시에 합주를 하는데요.
멤버들이 너무 상습적으로 늦어서, 1분에 1달러씩 내야 하는 벌금 제도를 도입했습니다.

그런데 마침 익중이와 친구 넷이 놀다가 또 지각할 위기입니다. 아직 악보도 출력해 놓지 않은 상황이죠.
어차피 같이 놀다 늦은 것이니 벌금을 다섯 명이서 똑같이 나눠 내기로 하고, 벌금을 가능한 적게 내는 방법을 고민해 보기로 합니다.

다섯 사람이 각각 출력해야 하는 페이지 수는 3장, 1장, 4장, 3장, 2장입니다. 프린터는 한 대밖에 없고, 1장을 출력하기 위해서는 1분이 걸립니다.
현재 순서대로 출력한다면,

첫 번째 사람: 3분 지각
두 번째 사람: 3 + 1분 지각
세 번째 사람: 3 + 1 + 4분 지각
네 번째 사람: 3 + 1 + 4 + 3분 지각
다섯 번째 사람: 3 + 1 + 4 + 3 + 2분 지각
총 39달러의 벌금을 내야 합니다.

흠… 더 적게 내는 방법이 있지 않을까요?

출력할 페이지 수가 담긴 리스트 pages_to_print를 파라미터로 받고 최소 벌금을 리턴해 주는 함수 min_fee를 작성해 보세요.

[이 문제는 최적 부분 구조와 탐욕적 선택 속성 둘 다 있기 때문에, Greedy Algorithm으로 최적의 솔루션을 구할 수 있다]
1. 최적 부분 구조
    첫 번째 사람이 먼저 출력한다고 가정하면,
    첫 번째 사람: 3분 지각
    두 번째 사람: 3 + a분 지각
    세 번째 사람: 3 + a + b분 지각
    네 번째 사람: 3 + a + b + c분 지각
    다섯 번째 사람: 3 + a + b + c + d분 지각
    첫 번째 사람을 기다리느라 모든 친구들이 각각 최소 3분씩 지각하게 됩니다.

    그 후에는 남은 친구들이 어떤 순서로 출력하는 게 좋을지 결정해야 하는데요. 코드로 표현하면 이렇게 되겠네요.
    -> 3 * 5 + min_fee([1, 4, 3, 2])

    만약 두 번째 사람이 먼저 출력한다고 가정하면 이렇게 되겠죠.
    -> 1 * 5 + min_fee([3, 4, 3, 2])

    이런식으로 가능한 모든 경우로 나누면 다섯 경우로 나눌 수 있습니다.
    각 경우의 부분 문제를 풀고 서로 비교해서 최적의 경우를 선택하면, 기존 문제의 최적의 답을 구할 수 있습니다. 따라서 이 문제에는 최적 부분 구조가 있습니다.

2. 탐욕적 선택 속성
    매 단계마다 가장 좋아 보이는 선택은 무엇일까요?
    세 명이 각각 100장, 2장, 1장을 출력한다고 가정합시다.
    만약 첫 번째 사람이 먼저 출력하면 세 명 모두 최소 100분을 기다려야겠죠.
    반대로 마지막 사람이 먼저 출력을 하면 세 명 모두 최소 1분을 기다려야 합니다.
    기다리는 시간을 최소화하기 위해서는, 페이지 수가 적은 사람 순으로 출력하는 것이 최선이라고 확신할 수 있습니다.
    따라서 이 문제는 탐욕적 선택 속성도 있습니다.
'''
def min_fee(pages_to_print):
    # 낮은 순으로 정렬(오름차순)
    pages_to_print.sort(reverse = False)

    # 짧은 순부터 합계 구하기
    fee_list = []
    total = 0
    for i in pages_to_print:
        total += i
        fee_list.append(total)

    return sum(fee_list)


# 테스트
print(min_fee([6, 11, 4, 1]))
print(min_fee([3, 2, 1]))
print(min_fee([3, 1, 4, 3, 2]))
print(min_fee([8, 4, 2, 3, 9, 23, 6, 8]))

# 다른 풀이 코드
def min_fee(pages_to_print):
    # 인풋으로 받은 리스트를 정렬시켜 준다
    sorted_list = sorted(pages_to_print)

    # 총 벌금을 담을 변수
    total_fee = 0

    # 정렬된 리스트에서 총 벌금 계산
    for i in range(len(sorted_list)):
        total_fee += sorted_list[i] * (len(sorted_list) - i)

    return total_fee